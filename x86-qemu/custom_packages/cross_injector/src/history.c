/*!
 * @file src/history.c
 * @brief can be used to ensure the same packet is not injected more than once
 * @details
 * The motivation for this is to avoid an injected packet to be captured and injected back, creating a storm. In practice, this does not
 * appear to happen, so this does not currently seem to be needed.
 *
 * fine-print: Copyright (c) 2020-2021, David Hamilton <david@davidohamilton.com>. This software may be freely copied and used under GPLv2 (see LICENSE.txt in root directory).
 */

#define HISTORY_TEST

#include "history.h"
#include <pthread.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

uint64_t history[HISTORY];  // history of injected packets to avoid echoing packets that were injected
uint16_t last_history;
pthread_mutex_t history_lock;

// packets with hash of exactly zero will be ignored/dropped (accepted since Wi-Fi isn't a perfect medium anyway)
void history_init() {
    for (int i=0; i<HISTORY; i++) history[i]=0;
    last_history=0;
    if (pthread_mutex_init(&history_lock, NULL) != 0) {
        printf("\n mutex init has failed!!\n");
    }
}

// simple uniform hash for range of 255 characters (note that window of character ordering is 8 bytes using an 8 byte integer sum)
uint64_t history_hash(const u_char *pkt,uint32_t pkt_size) {
  uint64_t sum;
  sum=0;
  for (int i=0; i<pkt_size; i++) {
    sum = HASH_MULTIPLIER * sum + (uint8_t) pkt[i];
  }
  return sum;
}

// was seen before -> was_injected := 1
// not seen in history -> was_injected := 0 and remember hash
int history_was_injected(uint8_t * pkt, uint32_t pkt_size) {
    uint8_t found;
    uint64_t this_hash;
    uint8_t retval;

    this_hash = history_hash(pkt, pkt_size);
    found = 0;
    pthread_mutex_lock(&history_lock);
    for (int i=0; i<HISTORY && !found; i++) {
        if (this_hash == history[i]) found = 1;
    }
    if (found) retval=1;
    else {
        last_history++;
        if (last_history >= HISTORY) last_history=0;
        history[last_history] = this_hash;
        retval=0;
    }
    pthread_mutex_unlock(&history_lock);
    return retval;
}

#ifdef HISTORY_TEST
// Imported from file 'beacon1.pkt'
static  unsigned char beacon1[] = {
	0xd4,0xc3,0xb2,0xa1,0x02,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x7f,0x00,0x00,0x00,0x17,0xbe,0xe2,0x5e,0x17,0xa9,0x00,0x00,0x6c,0x00,0x00,0x00,0x6c,0x00,0x00,0x00,0x00,0x00,0x16,0x00,0x0f,0x00,0x00,0x00,0xcd,0x1c,0x0b,0x51,0xd7,0xa7,0x05,0x00,0x00,0x02,0x85,0x09,0xa0,0x00,0x80,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x00,0x00,0x02,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x8a,0x1d,0x0b,0x51,0xd7,0xa7,0x05,0x00,0xf4,0x01,0x01,0x04,0x00,0x06,0x74,0x65,0x73,0x74,0x61,0x70,0x01,0x08,0x82,0x84,0x8b,0x96,0x0c,0x12,0x18,0x24,0x03,0x01,0x06,0x05,0x04,0x01,0x02,0x00,0x00,0x2a,0x01,0x04,0x32,0x04,0x30,0x48,0x60,0x6c,0x3b,0x02,0x51,0x00,0x7f,0x08,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x40
};
static  unsigned int beacon1_len = 148;

// Imported from file 'beacon2.pkt'
static  unsigned char beacon2[] = {
	0xd4,0xc3,0xb2,0xa1,0x02,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x7f,0x00,0x00,0x00,0x1c,0xbe,0xe2,0x5e,0xc5,0x4d,0x0a,0x00,0x6c,0x00,0x00,0x00,0x6c,0x00,0x00,0x00,0x00,0x00,0x16,0x00,0x0f,0x00,0x00,0x00,0xbc,0x0c,0x61,0x51,0xd7,0xa7,0x05,0x00,0x00,0x02,0x85,0x09,0xa0,0x00,0x80,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x00,0x00,0x02,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x79,0x0d,0x61,0x51,0xd7,0xa7,0x05,0x00,0xf4,0x01,0x01,0x04,0x00,0x06,0x74,0x65,0x73,0x74,0x61,0x70,0x01,0x08,0x82,0x84,0x8b,0x96,0x0c,0x12,0x18,0x24,0x03,0x01,0x06,0x05,0x04,0x00,0x02,0x00,0x00,0x2a,0x01,0x04,0x32,0x04,0x30,0x48,0x60,0x6c,0x3b,0x02,0x51,0x00,0x7f,0x08,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x40
};
static  unsigned int beacon2_len = 148;

// Imported from file 'beacon3.pkt'
static  unsigned char beacon3[] = {
	0xd4,0xc3,0xb2,0xa1,0x02,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x7f,0x00,0x00,0x00,0x20,0xbe,0xe2,0x5e,0xb6,0xc4,0x0b,0x00,0x6c,0x00,0x00,0x00,0x6c,0x00,0x00,0x00,0x00,0x00,0x16,0x00,0x0f,0x00,0x00,0x00,0xb0,0x8c,0x9f,0x51,0xd7,0xa7,0x05,0x00,0x00,0x02,0x85,0x09,0xa0,0x00,0x80,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x00,0x00,0x02,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x6d,0x8d,0x9f,0x51,0xd7,0xa7,0x05,0x00,0xf4,0x01,0x01,0x04,0x00,0x06,0x74,0x65,0x73,0x74,0x61,0x70,0x01,0x08,0x82,0x84,0x8b,0x96,0x0c,0x12,0x18,0x24,0x03,0x01,0x06,0x05,0x04,0x00,0x02,0x00,0x00,0x2a,0x01,0x04,0x32,0x04,0x30,0x48,0x60,0x6c,0x3b,0x02,0x51,0x00,0x7f,0x08,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x40
};
static  unsigned int beacon3_len = 148;

//single threaded test
void history_test() {
    assert(!history_was_injected(beacon1, beacon1_len));
    assert(!history_was_injected(beacon2, beacon2_len));
    assert(!history_was_injected(beacon3, beacon3_len));
    assert(history_was_injected(beacon2, beacon2_len));
    assert(history_was_injected(beacon3, beacon3_len));
}


#endif // HISTORY_TEST


